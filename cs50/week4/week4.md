
# CS50 - week 4 : 알고리즘

## 1. 검색 알고리즘

### 선형검색, 이진검색

**선형검색(Linear Search)**
 - 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사한다. 
 - 순차검색(SequentialSearch)라고도 한다. 
 - 정렬되지 않은 리스트에서 사용할 수 있다는 장점이 있다.

**이진검색(Binary Search)**
- 만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은 인덱스 또는 큰 인덱스로 이동을 반복하여 탐색한다. 즉 중간값부터 탐색을 한다. 
- 빠른 처리속도의 장점을 가지고 있다. 
- 정렬된 리스트에만 사용할 수 있다는 단점이 있다.


## 2. 알고리즘 표기법

### Big O , Big Ω

**Big O**
- 알고리즘 실행 시간의 상한을 나타낸 것(최악의 경우)

**Big Ω**
- 알고리즘 실행 시간의 하한을 나타낸 것(최선의 경우)


## 3. 선형검색

### 선형탐색

**선형검색**
- 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색한다.
- 찾고자 하는 자료를 찾을때 까지 모든 자료를 확인해야 한다.

**효율성 그리고 비효율성**
- 정확하지만 효율적이지 못한 방법이다.
- 최악의 경우 리스트의 모든 원소를 확인해야 하므로 n번만큼 실행된다.
- 찾고자 하는 자료가 마지막에 있거나 리스트 안에 없는 경우 최악의 상황이여서 
효율성이 매우 떨어진다.
- 최선의 경우 처음에 찾고자 하는 값이 있는 경우다.
- 자료가 정렬되어 있지 않거나 정보가 없어 하나씩 찾아야 하는 경우에 유용하다.

## 4. 버블정렬
 ### 버블정렬(거품정렬)

- 인접한 두 원소를 검사하여 정렬하는 방법이다.
- 좀 더 자세하게, 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말한다.
- 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수 있다.
- 버블 정렬 실행 시간의 상한은 O(n^2) 이다.
```
예시) 
교환 전: 5 3 7 9 1 4 2 --> 먼저 가장 앞의 5와 3을 비교해서 순서를 바꾼다.
교환 후: 3 5 7 9 1 4 2  

교환 전: 3 5 7 9 1 4 2  --> 5와 7을 비교하지만 교환할 필요가 없으니 그대로 둔다.
교환 후: 3 5 7 9 1 4 2

...

교환 후: 3 5 7 1 4 2 9 --> 숫자 끝까지 한 번 진행 한 결과

오름차순으로 정렬이 되지 않아서 다시 처음부터 동일한 작업 반복 진행한다.

최종 교환 후: 1 2 3 4 5 7 9
```

  ## 5. 선택정렬
### 선택정렬
  
- 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬.

- 더 자세히, 주어진 리스트 중에 최소값을 찾는다 그리고 그 값을 맨 앞에 위치한 값과 교체한다. 그 다음에 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.


```
예시)

6 3 5 2 7 4 1

6 3 5 2 7 4 **1** --> 가장 작은 값을 찾는다.

**1** 3 5 2 7 4 **6** --> 가장 작은 값인 1을 앞으로, 첫번째 값인 6 과 교환 한다.

1 3 5 **2** 7 4 6 --> 1을 제외하고 두번째 숫자부터 시작해 작은 값을 찾는다.

1 2 5 3 7 4 6 --> 가장 작은 값인 2를 앞으로, 3과 교환한다.

동일한 작업을 반복 진행 한다.

오름차순 정렬 완료 후: 1 2 3 4 5 6 7

```

출처: edwith, 위키피디아